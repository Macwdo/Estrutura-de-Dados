#include <stdio.h>
#include <stdlib.h>

struct no{
    int chave;
    struct no *esquerda;
    struct no *direita;
};

//esta funçao retornará o novo nó com o valor fornecido

struct no *getNovoNo(int val){
    struct no *novoNo = malloc(sizeof(struct no));
    novoNo->chave = val;
    novoNo->esquerda = NULL;
    novoNo->direita = NULL;
    return novoNo;
};

struct no *inserir(struct no *raiz, int val){
    /* 
    Ele vai lidar com dois casos,
    1. se a árvore estiver vazia, retorna um novo nó na raiz
    2. se o percuso da árvore atingir NULL, ele retornará o novo nó
    */
    if (raiz==NULL)return getNovoNo(val);
    /*
    se dado val for maior que raiz->chave
    devemos encontrar o lugar correto na subárvore direita e inserir o novo nó
    */
    if (raiz->chave < val)
        raiz->direita = inserir(raiz->direita, val);
    /*
    se dado val for menor que raiz->chave,
    devemos encontrar o lugar correto na subárvore direita e inserir o novo nó
    */
    else if (raiz->chave > val)
        raiz->esquerda = inserir(raiz->esquerda, val);
    /*
    Ele vai lidar com dois  casos
    (Evite os nós duplicados na árvore)
    1.Se raiz->chave == val ele retornará imediatamente o endereço do nó raiz
    2.Após a inserção, ele retornará o endereço da raiz original inalterado 
    */
    return raiz;
};

void ordena(struct no *raiz){
    if (raiz==NULL)
        return;
    ordena(raiz->esquerda);
    printf("%d ",raiz->chave);
    ordena(raiz->direita);
};

// Mesmo código anterior, continuando após inserir.
int getdireitaMin(struct no *raiz){
    struct no *temp = raiz;
    // min valor deve estar presente no nó mais á esquerda.
    while (temp->esquerda != NULL){
        temp = temp->esquerda;
    }
    return temp->chave;
}

struct no *removeno(struct no *raiz, int val){
    /*
    Se o nó se tornar NULL, ele retornará NULL
    Duas maneiras possíveis que podem desencadear este caso
    1. Se enviarmos a árvore vazia. ou seja, raiz == NULL
    2. Se o nó fornecido não estiver presente na árvore.
    */
    if (raiz == NULL)
        return NULL;
        
    /* 
    Se raiz->chave < val. val deve estar presente na subárvore direita 
    então , chame a função remove acima com raiz->right
    */
    if (raiz->chave < val)
        raiz->direita = removeno(raiz->direita,val);
    /*
    Se raiz->chave > val. val deve estar presente na subárvore esquerda
    então , chame a função acima com raiz->left.
    */
    
    else if (raiz->chave > val)
        raiz->esquerda = removeno(raiz->esquerda,val);
    
    /*
    Esta pate será executada somente se raiz->chave == val
    A remoção real começa a partir daqui
    */
    else{
        /*
        caso 1 : Nó folha. A referência esquerda e direita é NULL
        Substitua o nó por NULL retornando NULL para o ponteiro de chamada.
        libera o nó
        */
        if (raiz->esquerda == NULL && raiz->direita == NULL){
            free(raiz);
            return NULL;
        }
        /*
        caso 2: No tem filho certo.
        Substitua o nó raiz por raiz->direita e libere o nó certo
        */
        else if (raiz->esquerda==NULL){
            struct no *tempo = raiz->direita;
            free(raiz);
            return tempo;
        }
        else if (raiz->direita==NULL){
            struct no *tempo = raiz->esquerda;
            free(raiz);
            return tempo;
        }
        else{
            int direitaMin = getdireitaMin(raiz->direita);
            raiz->chave = direitaMin;
            raiz->direita = removeno(raiz->direita,direitaMin);
        }
    }
    return raiz;
    
    
}

int main(){
    struct no *raiz = NULL;
    raiz = inserir(raiz,10);
    raiz = inserir(raiz,5);
    raiz = inserir(raiz,15);
    raiz = inserir(raiz,46);
    raiz = inserir(raiz,15);
    raiz = inserir(raiz,5);
    ordena(raiz);
    printf("\n");
    raiz = removeno(raiz,15);
    ordena(raiz);
    printf("\n");
    raiz = removeno(raiz,10);
    ordena(raiz);
    printf("\n");
    raiz = removeno(raiz,46);
    ordena(raiz);
    return 0;

}

